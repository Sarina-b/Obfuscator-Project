# ast_builder.py

class Node:
    pass

class ProgramNode(Node):
    def __init__(self, declarations_and_functions):
        self.declarations_and_functions = declarations_and_functions

class FunctionDeclarationNode(Node):
    def __init__(self, return_type, name, params, body):
        self.return_type = return_type
        self.name = name
        self.params = params # list of ParamNode
        self.body = body     # BlockNode

class VariableDeclarationNode(Node):
    def __init__(self, var_type, name, initializer=None):
        self.var_type = var_type
        self.name = name
        self.initializer = initializer # ExpressionNode or None

class AssignmentNode(Node):
    def __init__(self, identifier, expression):
        self.identifier = identifier # IdentifierNode
        self.expression = expression # ExpressionNode

class IfStatementNode(Node):
    # ...
    pass

class WhileStatementNode(Node):
    # ...
    pass

class BinaryOpNode(Node):
    def __init__(self, left, operator, right):
        self.left = left
        self.operator = operator
        self.right = right

# ... other nodes like IdentifierNode, LiteralNode, FunctionCallNode, PrintfNode, etc.
# ast_builder.py (continued)
from MiniCParser import MiniCParser
from MiniCVisitor import MiniCVisitor # Generated by ANTLR

class AstBuilder(MiniCVisitor):
    def visitProgram(self, ctx:MiniCParser.ProgramContext):
        # Logic to visit children and construct a ProgramNode
        items = []
        for item_ctx in ctx.children:
            if hasattr(item_ctx, 'functionDefinition'): # Example check
                items.append(self.visit(item_ctx.functionDefinition()))
            elif hasattr(item_ctx, 'declaration'):
                 items.append(self.visit(item_ctx.declaration()))
        return ProgramNode(items)

    def visitFunctionDefinition(self, ctx:MiniCParser.FunctionDefinitionContext):
        return_type = ctx.type_().getText()
        name = ctx.IDENTIFIER().getText()
        params = self.visit(ctx.parameterList()) if ctx.parameterList() else []
        body = self.visit(ctx.block())
        return FunctionDeclarationNode(return_type, name, params, body)

    def visitBinaryExpression(self, ctx:MiniCParser.BinaryExpressionContext): # Assuming you have such a rule
        left = self.visit(ctx.expression(0))
        op = ctx.op.text # e.g., ctx.getChild(1).getText()
        right = self.visit(ctx.expression(1))
        return BinaryOpNode(left, op, right)

    # ... override other visit methods for all relevant grammar rules